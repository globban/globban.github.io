<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drift</title>
  <script src="https://kit.fontawesome.com/87a560d2c6.js" crossorigin="anonymous"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000000;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #3d3d3d;
      width: 100vw;
      height: 100vh;
    }
    #colorMenu {
      position: absolute;
      bottom: 10vh;
      left: 50%;
      transform: translateX(-50%);
      width: 80vw;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      font-family: sans-serif;
      font-size: 25px;
      display: none;
      z-index: 1200;
    }
    #colorMenu input[type="range"] {
      width: 80vw;
      height: 6vh;
      margin: 10px 0;
    }
    #menubutton {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: transparent;
      color: #ffffff;
      font-size: 69px;
      z-index: 9999;
      cursor: pointer;
    }
    #mobile-only {
      display: none;
    }
    .touch-only {
      display: block;
    }
    #watermark {
      position: absolute;
      top: 10px;
      right: 20px;
      color: #aaa;
      font-size: 20px;
      font-family: 'Courier New', Courier, monospace;
    }
    h1 {
      position: absolute;
      color: #fff;
      z-index: 999;
      top: 50vh;
      left: 50vw;
      transform: translate(-50%, -50%);
      font-family: 'Courier New', Courier, monospace;
      font-size: 3em;
    }
    #mobileControls button {
      width: 45vw;
      height: 100vh;
      font-size: 2em;
      margin: 5px;
      border-radius: 10px;
      border: none;
      background-color: #22222200;
      color: #ffffff10;
    }
    #mobileControls {
      position: absolute;
      bottom: 0px;
      width: 100vw;
      text-align: center;
      z-index: 1000;
    }

    #speedmenu {
      position: absolute;
      top: 1vh;
      left: 50%;
      transform: translateX(-50%);
      width: fit-content;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      z-index: 1201;
      font-family: sans-serif;
      font-size: 25px;
    }

    #speedmenu input[type="range"] {
      width: 7em;
    }
  </style>
</head>
<body>
  <div id="menubutton" onclick="menu()"><i class="fas fa-fill-drip"></i></div>
  <div id="watermark">Algots drift workshop</div>

  <div id="colorMenu">
    <label for="hueSlider">Car Hue:</label>
    <input type="range" id="hueSlider" min="0" max="360" value="0"><br>
    <label for="saturationSlider">Saturation:</label>
    <input type="range" id="saturationSlider" min="0" max="200" value="100"><br>
    <label for="brightnessSlider">Brightness:</label>
    <input type="range" id="brightnessSlider" min="0" max="200" value="100"><br>
  </div>
  <div id="speedmenu">
  <label for="SpeedSlider">Speed:</label>
  <input type="range" id="SpeedSlider" min="1" max="20" value="12">
</div>
  <canvas id="gameCanvas"></canvas>

  <div id="mobile-only" class="touch-only">
    <div id="mobileControls">
      <div id="start">
        <h1>Press to Start</h1>
      </div>
      <button id="leftBtn">Left</button>
      <button id="rightBtn">Right</button>
    </div>
  </div>

  <script>
    // Input & UI setup
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const hueSlider = document.getElementById("hueSlider");
    const saturationSlider = document.getElementById("saturationSlider");
    const brightnessSlider = document.getElementById("brightnessSlider");
    const keys = {};

    // Touch handlers
    leftBtn.addEventListener("touchstart", e => {
      e.preventDefault();
      keys["ArrowLeft"] = true;
      keys["ArrowUp"] = true;
      document.getElementById("start").style.display = "none";
    });
    leftBtn.addEventListener("touchend", e => {
      e.preventDefault();
      keys["ArrowLeft"] = false;
    });
    rightBtn.addEventListener("touchstart", e => {
      e.preventDefault();
      keys["ArrowRight"] = true;
      keys["ArrowUp"] = true;
      document.getElementById("start").style.display = "none";
    });
    rightBtn.addEventListener("touchend", e => {
      e.preventDefault();
      keys["ArrowRight"] = false;
    });

    // Color persistence
    ['Hue','Saturation','Brightness'].forEach(prop => {
      const key = 'car' + prop;
      const slider = document.getElementById(prop.toLowerCase() + 'Slider');
      const saved = localStorage.getItem(key);
      if (saved !== null) slider.value = saved;
      slider.addEventListener('input', e => {
        config[prop.toLowerCase()] = e.target.value;
        localStorage.setItem(key, e.target.value);
      });
    });

    function menu() {
      const cm = document.getElementById("colorMenu");
      cm.style.display = cm.style.display === "block" ? "none" : "block";
    }

    if (!window.matchMedia('(any-hover: hover)').matches && 'ontouchstart' in window) {
      document.getElementById('mobile-only').style.display = "block";
    }

    // Game config
    const config = {
      baseCar: { w: 47, h: 100, pivotOffset: 30 },
      baseWheelbase: 57,
      maxSpeed: 14,
      friction: 0.98,
      accelFwd: 0.07,
      accelBack: -0.03,
      steeringRate: 0.02,
      maxSteer: 0.5,
      driftFactor: 0.01,
      carSrc: 'car.png',
      hitboxScale: 0.85,
      hue: 0,
      saturation: 100,
      brightness: 100
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const carImg = new Image();
    carImg.src = config.carSrc;

    let scale = 1, dpr = 1, obstacles = [];

    function resize() {
      dpr = devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      scale = Math.min(window.innerWidth / 1920, window.innerHeight / 1080);

      // Regenerate obstacles
      const baseObs = generateRandomObstacles(12);
      obstacles = baseObs.map(o => ({
        x: (canvas.width/4) + o.x * scale * dpr,
        y: (canvas.height/4) + o.y * scale * dpr,
        width: o.width * scale * dpr,
        height: o.height * scale * dpr,
        angle: o.angle
      }));

      // No more resolution‐based scaling—use base values
      config.scaledMaxSpeed   = config.maxSpeed;
      config.scaledAccelFwd   = config.accelFwd;
      config.scaledAccelBack  = config.accelBack;
    }

    window.addEventListener('resize', resize);

    const car = { x:0, y:0, angle:Math.PI/2, vAngle:Math.PI/2, velocity:0, steering:0 };
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup',   e => keys[e.key] = false);

    function update(speedMultiplier) {
      // Auto full‐throttle on mobile
      if (document.getElementById('mobile-only').style.display === "block") {
        keys.ArrowUp = true;
      }

      let accel = 0;
      if (keys.ArrowUp   || keys.w || keys.W) accel = config.scaledAccelFwd;
  else if (keys.ArrowDown || keys.s || keys.S) accel = config.scaledAccelBack;

      car.velocity = (car.velocity + accel * speedMultiplier) * config.friction;
      car.velocity = Math.max(-config.scaledMaxSpeed/2,
                             Math.min(config.scaledMaxSpeed, car.velocity));

      if (keys.ArrowLeft || keys.A || keys.a)      car.steering -= config.steeringRate * speedMultiplier;
      else if (keys.ArrowRight || keys.D || keys.d ) car.steering += config.steeringRate * speedMultiplier;
      else                      car.steering *= 0.5;
      car.steering = Math.max(-config.maxSteer,
                              Math.min(config.maxSteer, car.steering));

      car.angle  += (car.velocity / (config.baseWheelbase * scale * dpr))
                    * Math.tan(car.steering) * speedMultiplier;
      car.vAngle += (car.angle - car.vAngle) * config.driftFactor;
      car.x     += car.velocity * Math.cos(car.vAngle) * speedMultiplier;
      car.y     += car.velocity * Math.sin(car.vAngle) * speedMultiplier;
    }

    const savedHue = localStorage.getItem("carHue");
    if (savedHue !== null) {
      config.hue = savedHue;
      hueSlider.value = savedHue;
    }
    const savedSaturation = localStorage.getItem("carSaturation");
    if (savedSaturation !== null) {
      config.saturation = savedSaturation;
      saturationSlider.value = savedSaturation;
    }
    const savedBrightness = localStorage.getItem("carBrightness");
    if (savedBrightness !== null) {
      config.brightness = savedBrightness;
      brightnessSlider.value = savedBrightness;
    }

    hueSlider.addEventListener("input", e => {
      config.hue = e.target.value;
      localStorage.setItem("carHue", config.hue);
    });
    saturationSlider.addEventListener("input", e => {
      config.saturation = e.target.value;
      localStorage.setItem("carSaturation", config.saturation);
    });
    brightnessSlider.addEventListener("input", e => {
      config.brightness = e.target.value;
      localStorage.setItem("carBrightness", config.brightness);
    });

    const SpeedSlider = document.getElementById("SpeedSlider");
const savedSpeed = localStorage.getItem("addspeed"); // Load saved speed value if it exists
let addspeed = savedSpeed ? parseFloat(savedSpeed) : 0; // Initialize addspeed with saved value, or default to 0

// Update the speed value on input
SpeedSlider.value = addspeed; // Set the slider to the saved value (or default)

// Event listener to update addspeed and save it in localStorage
SpeedSlider.addEventListener("input", (e) => {
  addspeed = parseFloat(e.target.value); // Update the global addspeed value

  // Save the new value in localStorage
  localStorage.setItem("addspeed", addspeed);
  console.log("New speed: ", addspeed);
});

  // Existing code for menu functionality
  function menu() {
    const cm = document.getElementById("colorMenu");
    cm.style.display = cm.style.display === "block" ? "none" : "block";
  }
    

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#888';
      obstacles.forEach(o => ctx.fillRect(o.x, o.y, o.width, o.height));

      if (carImg.complete) {
        const w = config.baseCar.w * scale * dpr;
        const h = config.baseCar.h * scale * dpr;
        const pivot = config.baseCar.pivotOffset * scale * dpr;

        ctx.save();
        ctx.translate(car.x, car.y);
        ctx.rotate(car.angle + Math.PI/2);
        ctx.filter = `hue-rotate(${config.hue}deg)
                      saturate(${config.saturation}%)
                      brightness(${config.brightness}%)`;
        ctx.drawImage(carImg, -w/2, -h/2 - pivot, w, h);
        ctx.filter = 'none';

        // hitbox (invisible)
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#00000000';
        ctx.lineWidth = 3;
        ctx.strokeRect(-w*config.hitboxScale/2,
                       -h*config.hitboxScale/2 - pivot,
                       w*config.hitboxScale,
                       h*config.hitboxScale);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }

    function checkCollision() {
      const w = config.baseCar.w * scale * dpr * config.hitboxScale * 0.5;
      const h = config.baseCar.h * scale * dpr * config.hitboxScale * 0.5;
      const pivot = config.baseCar.pivotOffset * scale * dpr;
      const sin = Math.sin(car.angle + Math.PI/2);
      const cos = Math.cos(car.angle + Math.PI/2);
      const corners = [
        { x: car.x + (-w/2)*cos - (-h/2-pivot)*sin,
          y: car.y + (-w/2)*sin + (-h/2-pivot)*cos },
        { x: car.x + ( w/2)*cos - (-h/2-pivot)*sin,
          y: car.y + ( w/2)*sin + (-h/2-pivot)*cos },
        { x: car.x + ( w/2)*cos - ( h/2-pivot)*sin,
          y: car.y + ( w/2)*sin + ( h/2-pivot)*cos },
        { x: car.x + (-w/2)*cos - ( h/2-pivot)*sin,
          y: car.y + (-w/2)*sin + ( h/2-pivot)*cos }
      ];
      for (let o of obstacles) {
        for (let c of corners) {
          if (c.x > o.x && c.x < o.x + o.width &&
              c.y > o.y && c.y < o.y + o.height) {
            car.velocity = car.velocity * 0.5; // slow down on collision
            return;
          }
        }
      }
    }

    function generateRandomObstacles(num) {
      const min = 50, max = 150;
      const arr = [];
      for (let i = 0; i < num; i++) {
        const w = Math.random()*(max-min)+min;
        const h = Math.random()*(max-min)+min;
        arr.push({
          x: Math.random()*(canvas.width-w),
          y: Math.random()*(canvas.height-h),
          width: w, height: h,
          angle: Math.random()*Math.PI*2
        });
      }
      return arr;
    }

    // === new FPS‐compensated loop ===
    let lastTs = performance.now();
    function loop(ts) {
      const delta = ts - lastTs;
      lastTs = ts;
      const speedMult = (addspeed / 10); // 1 at 60 FPS, >1 if slower
      update(speedMult);
      checkCollision();
      // wrap
      if (car.x<0)          car.x = canvas.width;
      if (car.x>canvas.width) car.x = 0;
      if (car.y<0)          car.y = canvas.height;
      if (car.y>canvas.height) car.y = 0;
      draw();
      requestAnimationFrame(loop);
    }

    // start
    resize();
    car.x = canvas.width/2;
    car.y = canvas.height/2;
    requestAnimationFrame(loop);

    
  </script>
</body>
</html>
