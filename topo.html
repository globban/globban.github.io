<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Procedural Topographic</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    #topo {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="topo"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.181.2/build/three.module.js";

    const width = window.innerWidth;
    const height = window.innerHeight;

    const scene = new THREE.Scene();

    // FIXED orthographic camera
    const camera = new THREE.OrthographicCamera(
      0, width,
      height, 0,
      1, 10
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    document.getElementById("topo").appendChild(renderer.domElement);

    const geometry = new THREE.PlaneGeometry(width, height);
    geometry.translate(width / 2, height / 2, 0);

    // FIXED shader (added precision and WebGL2 safe)
    const vertexShader = `
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

   const fragmentShader = `
  precision highp float;

  uniform float time;

  // --- Simplex-style noise (IQ) ---
  vec2 hash(vec2 p) {
      p = vec2(dot(p, vec2(127.1, 311.7)),
               dot(p, vec2(269.5, 183.3)));
      return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
  }

  float noise(in vec2 p) {
      const float K1 = 0.366025404; 
      const float K2 = 0.211324865;

      vec2 i = floor(p + (p.x + p.y) * K1);
      vec2 a = p - i + (i.x + i.y) * K2;
      vec2 o = step(a.yx, a.xy);
      vec2 b = a - o + K2;
      vec2 c = a - 1.0 + 2.0 * K2;

      vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
      vec3 n = h*h*h*h * vec3(dot(a,hash(i)),
                              dot(b,hash(i+o)),
                              dot(c,hash(i+1.0)));
      return dot(n, vec3(70.0));
  }

  // --- Domain warp ---
  vec2 warp(vec2 p, float t) {
      float w1 = noise(p + vec2(t * 0.10, t * 0.05));
      float w2 = noise(p + vec2(-t * 0.05, t * 0.12));
      return p + vec2(w1, w2) * 0.4;   // warp strength
  }

  void main() {
      vec2 uv = gl_FragCoord.xy / vec2(${width.toFixed(1)}, ${height.toFixed(1)});
      uv *= 2.5;

      // apply domain warp twice for organic look
      uv = warp(uv, time);
      uv = warp(uv, time * 0.5);

      float h = noise(uv);

      // contour lines
      float lines = fract(h * 6.0);

      // thicker lines
      float thickness = 0.06;
      float contour = smoothstep(thickness, 0.0, abs(lines - 0.5));

      gl_FragColor = vec4(vec3(contour), 1.0);
  }
`;



    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: { time: { value: 0.0 } }
    });

    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      material.uniforms.time.value = clock.getElapsedTime();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
