<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drifting Car</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; background: #1c1c1c; }
    /* Simple position for control panel */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 10;
    }
    #controls label {
      margin-right: 10px;
    }
    #controls button {
      padding: 5px 10px;
      font-size: 14px;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      Car Hue:
      <input type="range" id="carHue" min="0" max="360" value="20">
      <span id="hueValue">20</span>
    </label>
    <button id="saveButton">Save</button>
  </div>
  <canvas id="game"></canvas>
  <script>
    // Setup canvas and context
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Handle keyboard input
    const keys = {};
    document.addEventListener('keydown', e => keys[e.key] = true);
    document.addEventListener('keyup', e => keys[e.key] = false);
    
    // Car object and defaults
    const car = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: 40,
      height: 20,
      angle: 0,
      velocityX: 0,
      velocityY: 0,
      acceleration: 1200,       // pixels/second^2
      friction: 0.98,           // general slowdown factor
      driftFactor: 1,           // lateral slide
      gripFactor: 1.3,          // steering response
      maxSpeed: 500             // pixels/second
    };
    
    // Load saved hue or default to 20
    let customCarHue = localStorage.getItem('carHue') || 20;
    // Create the car color in HSL using the hue slider value, fixed saturation/lightness
    let customCarColor = `hsl(${customCarHue}, 80%, 50%)`;
    
    // Update slider UI with loaded value
    const carHueSlider = document.getElementById('carHue');
    const hueValueDisplay = document.getElementById('hueValue');
    carHueSlider.value = customCarHue;
    hueValueDisplay.textContent = customCarHue;
    
    // Update hue on slider change, updating color and displayed value
    carHueSlider.addEventListener('input', (e) => {
      customCarHue = e.target.value;
      hueValueDisplay.textContent = customCarHue;
      customCarColor = `hsl(${customCarHue}, 80%, 50%)`;
    });
    
    // Save button persists the selected hue to localStorage
    document.getElementById('saveButton').addEventListener('click', () => {
      localStorage.setItem('carHue', customCarHue);
      alert('Car hue saved!');
    });
    
    let lastTime = performance.now();
    
    function updateCar(dt) {
      const steerInput = (keys['ArrowLeft'] ? -1 : 0) + (keys['ArrowRight'] ? 1 : 0);
      const throttle  = (keys['ArrowUp']   ? 1 : 0) + (keys['ArrowDown']  ? -1 : 0);
      
      // Apply throttle force
      const force = throttle * car.acceleration * dt;
      car.velocityX += Math.cos(car.angle) * force;
      car.velocityY += Math.sin(car.angle) * force;
      
      // Velocity decomposition
      const sin = Math.sin(car.angle);
      const cos = Math.cos(car.angle);
      const forwardVel = car.velocityX * cos + car.velocityY * sin;
      const lateralVel = -car.velocityX * sin + car.velocityY * cos;
      const adjustedLateralVel = lateralVel * car.driftFactor;
      
      // Recompose velocity
      car.velocityX = forwardVel * cos - adjustedLateralVel * sin;
      car.velocityY = forwardVel * sin + adjustedLateralVel * cos;
      
      // Limit speed
      const speed = Math.hypot(car.velocityX, car.velocityY);
      if (speed > car.maxSpeed) {
        const scale = car.maxSpeed / speed;
        car.velocityX *= scale;
        car.velocityY *= scale;
      }
      
      // Apply friction
      car.velocityX *= car.friction;
      car.velocityY *= car.friction;
      
      // Update position
      car.x += car.velocityX * dt;
      car.y += car.velocityY * dt;
      
      // Steering based on speed
      if (Math.abs(speed) > 5) {
        const steerStrength = steerInput * car.gripFactor / Math.max(speed, 50);
        car.angle += steerStrength * speed * dt * 3; // tuning factor
      }
      
      // Wrap around screen
      if (car.x < 0) car.x = canvas.width;
      if (car.x > canvas.width) car.x = 0;
      if (car.y < 0) car.y = canvas.height;
      if (car.y > canvas.height) car.y = 0;
    }
    
    function drawCar() {
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.angle);
      ctx.fillStyle = customCarColor;
      ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height);
      ctx.restore();
    }
    
    // Create an offscreen canvas for desaturation
    const offscreen = document.createElement('canvas');
    offscreen.width = canvas.width;
    offscreen.height = canvas.height;
    const offCtx = offscreen.getContext('2d');

    function loop(currentTime) {
      const dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      
      // 1. Fade the entire canvas slightly toward black.
      // Adjust the alpha (e.g. 0.05) to control fading speed.
      ctx.fillStyle = 'rgba(28, 28, 28, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 2. Convert the current canvas (the trail) to grayscale.
      // Use the offscreen canvas so the new car drawing is not affected.
      offCtx.clearRect(0, 0, offscreen.width, offscreen.height);
      offCtx.filter = 'grayscale(100%)';
      offCtx.drawImage(canvas, 0, 0);
      
      // 3. Blend the grayscale image back onto the main canvas with a low alpha.
      ctx.globalAlpha = 0.05;
      ctx.drawImage(offscreen, 0, 0);
      ctx.globalAlpha = 1;
      offCtx.filter = 'none';

      updateCar(dt);
      drawCar();
      
      requestAnimationFrame(loop);
    }
    
    requestAnimationFrame(loop);
  </script>
</body>
</html>
