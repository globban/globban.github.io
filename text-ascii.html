<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text to ASCII Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Background from topo.html */
        #background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            border: none;
        }

        #bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #snow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Main container */
        .main-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 10;
            overflow-y: auto;
        }

        /* Glass effect panels */
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            margin: 10px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            color: white;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Input section */
        .input-section {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.95em;
            font-weight: 500;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        input[type="text"]:focus,
        select:focus {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            outline: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        select {
            cursor: pointer;
        }

        select option {
            background: #1a1a2e;
            color: white;
        }

        /* Output section */
        .output-section {
            margin-top: 20px;
        }

        #output {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            line-height: 1.1;
            white-space: pre;
            word-break: break-all;
            max-height: 400px;
            overflow-y: auto;
            min-height: 100px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        /* Button styles */
        button {
            background: rgba(0, 255, 100, 0.3);
            border: 1px solid rgba(0, 255, 100, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            background: rgba(0, 255, 100, 0.5);
            box-shadow: 0 0 15px rgba(0, 255, 100, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        /* Scrollbar styling */
        #output::-webkit-scrollbar {
            width: 8px;
        }

        #output::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        #output::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 100, 0.5);
            border-radius: 10px;
        }

        #output::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 100, 0.7);
        }

        .status {
            text-align: center;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 10px;
            }

            .panel {
                padding: 15px;
                margin: 5px;
            }

            h1 {
                font-size: 1.5em;
            }

            #output {
                font-size: 0.65em;
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <!-- Background -->
   <iframe src="/topo.html" id="background-container"></iframe>

    <!-- Main Content -->
    <div class="main-container">
        <div class="panel">
            <h1>ASCII Art Generator</h1>
            
            <div class="status" id="status">Loading fonts...</div>

            <div class="input-section">
                <label for="textInput">Enter your text:</label>
                <input type="text" id="textInput" placeholder="Type something amazing..." autocomplete="off">
            </div>

            <div class="input-section">
                <label for="fontSelect">Choose a font:</label>
                <select id="fontSelect"></select>
            </div>

            <div class="button-group">
                <button onclick="generateASCII()">Generate ASCII</button>
                <button onclick="copyToClipboard()">Copy to Clipboard</button>
                <button onclick="downloadASCII()">Download</button>
                <button onclick="downloadPNG()">Download PNG</button>
            </div>

            <div class="output-section">
                <label for="output">ASCII Output:</label>
                <pre id="output"></pre>
            </div>
            
            <div class="input-section">
                <label for="textColor">Text color:</label>
                <input type="color" id="textColor" value="#ffffff">
                <label for="bgColor">Background color:</label>
                <input type="color" id="bgColor" value="#000000">
            </div>
        </div>
    </div>

    <script>
        // FLF Parser
        class FLFParser {
            constructor(fontData) {
                this.lines = fontData.split('\n');
                this.parseHeader();
                this.parseCharacters();
            }

            parseHeader() {
                const header = this.lines[0];
                const parts = header.split(/\s+/);
                
                if (!parts[0].startsWith('flf2')) {
                    throw new Error('Invalid FLF file format');
                }

                this.hardblank = parts[0][5] || '$';
                this.height = parseInt(parts[1]) || 8;
                this.baseline = parseInt(parts[2]) || 6;
                this.maxLength = parseInt(parts[3]) || 80;
                this.oldLayout = parseInt(parts[4]) || 0;
                this.commentLines = parseInt(parts[5]) || 0;
                this.printDirection = parseInt(parts[6]) || 0;
                this.fullLayout = parseInt(parts[7]) || 0;
                this.codeTagCount = parseInt(parts[8]) || 0;

                // Skip comment lines
                this.contentStartLine = 1 + this.commentLines;
            }

            parseCharacters() {
                this.characters = {};
                let currentLine = this.contentStartLine;

                // ASCII characters from 32 (space) to 126 (~)
                for (let charCode = 32; charCode <= 126; charCode++) {
                    const charLines = [];
                    for (let i = 0; i < this.height; i++) {
                        if (currentLine < this.lines.length) {
                            let line = this.lines[currentLine];
                            // Remove any @ or # markers at the end (with or without trailing spaces)
                            line = line.replace(/[@#]+\s*$/, '');
                            // Replace hardblank with space
                            line = line.replace(new RegExp(this.escapeRegex(this.hardblank), 'g'), ' ');
                            // Also remove any stray @ or # that might still be there
                            line = line.replace(/[@#]/g, ' ');
                            charLines.push(line);
                            currentLine++;
                        }
                    }
                    this.characters[String.fromCharCode(charCode)] = charLines;
                }
            }

            escapeRegex(str) {
                return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            renderText(text) {
                const result = [];
                for (let i = 0; i < this.height; i++) {
                    let line = '';
                    for (const char of text) {
                        const charLines = this.characters[char] || this.characters[' '];
                        if (charLines && charLines[i]) {
                            line += charLines[i];
                        }
                    }
                    result.push(line.trimEnd());
                }
                return result.join('\n');
            }
        }

        // Font list
        const allFonts = [
            "1Row", "3-D", "3D Diagonal", "3D-ASCII", "3d", "3d_diagonal", "3x5", "4Max",
            "5 Line Oblique", "5lineoblique", "AMC 3 Line", "AMC 3 Liv1", "AMC AAA01", "AMC Neko",
            "AMC Razor", "AMC Razor2", "AMC Slash", "AMC Slider", "AMC Thin", "AMC Tubes",
            "AMC Untitled", "ANSI Regular", "ANSI Shadow", "ASCII New Roman", "Acrobatic",
            "Alligator", "Alligator2", "alligator3", "Alpha", "Alphabet", "Arrows", "Avatar",
            "B1FF", "Banner", "Banner3-D", "Banner3", "Banner4", "Barbwire", "Basic", "Bear",
            "Bell", "Benjamin", "Big Chief", "Big Money-ne", "Big Money-nw", "Big Money-se",
            "Big Money-sw", "Big", "Bigfig", "Binary", "Block", "Blocks", "Bloody", "Bolger",
            "Braced", "Bright", "Broadway KB", "Broadway", "Bubble", "Bulbhead", "Caligraphy",
            "Caligraphy2", "Calvin S", "Cards", "Catwalk", "Chiseled", "Chunky", "Coinstak",
            "Cola", "Colossal", "Computer", "Contessa", "Contrast", "Cosmike", "Crawford",
            "Crawford2", "Crazy", "Cricket", "Cursive", "Cyberlarge", "Cybermedium",
            "Cybersmall", "Cygnet", "DANC4", "DOS Rebel", "DWhistled", "Dancing Font",
            "Decimal", "Def Leppard", "Delta Corps Priest 1", "Diamond", "Diet Cola", "Digital",
            "Doh", "Doom", "Dot Matrix", "Double Shorts", "Double", "Dr Pepper", "Efti Chess",
            "Efti Font", "Efti Italic", "Efti Piti", "Efti Robot", "Efti Wall", "Efti Water",
            "Electronic", "Elite", "Epic", "Fender", "Filter", "Fire Font-k", "Fire Font-s",
            "Flipped", "Flower Power", "Four Tops", "Fraktur", "Fun Face", "Fun Faces", "Fuzzy",
            "Georgi16", "Georgia11", "Ghost", "Ghoulish", "Glenyn", "Goofy", "Gothic", "Graceful",
            "Gradient", "Graffiti", "Greek", "Heart Left", "Heart Right", "Henry 3D", "Hex",
            "Hieroglyphs", "Hollywood", "Horizontal Left", "Horizontal Right", "ICL-1900",
            "Impossible", "Invita", "Isometric1", "Isometric2", "Isometric3", "Isometric4",
            "Italic", "Ivrit", "JS Block Letters", "JS Bracket Letters", "JS Capital Curves",
            "JS Cursive", "JS Stick Letters", "Jacky", "Jazmine", "Jerusalem", "Katakana",
            "Kban", "Keyboard", "Knob", "Konto Slant", "Konto", "LCD", "Larry 3D 2", "Larry 3D",
            "Lean", "Letters", "Lil Devil", "Line Blocks", "Linux", "Lockergnome", "Madrid",
            "Marquee", "Maxfour", "Merlin1", "Merlin2", "Mike", "Mini", "Mirror", "Mnemonic",
            "Modular", "Morse", "Morse2", "Moscow", "Mshebrew210", "Muzzle", "NScript",
            "NT Greek", "NV Script", "Nancyj-Fancy", "Nancyj-Improved", "Nancyj-Underlined",
            "Nancyj", "Nipples", "O8", "OS2", "Octal", "Ogre", "Old Banner", "Patorjk's Cheese",
            "Patorjk-HeX", "Pawp", "Peaks Slant", "Peaks", "Pebbles", "Pepper", "Poison", "Puffy",
            "Puzzle", "Pyramid", "Rammstein", "Rectangles", "Red Phoenix", "Relief", "Relief2",
            "Reverse", "Roman", "Rot13", "Rotated", "Rounded", "Rowan Cap", "Rozzo", "Runic",
            "Runyc", "S Blood", "SL Script", "Santa Clara", "Script", "Serifcap", "Shadow",
            "Shimrod", "Short", "Slant Relief", "Slant", "Slide", "Small Caps", "Small Isometric1",
            "Small Keyboard", "Small Poison", "Small Script", "Small Shadow", "Small Slant",
            "Small Tengwar", "Small", "Soft", "Speed", "Spliff", "Stacey", "Stampate",
            "Stampatello", "Standard", "Star Strips", "Star Wars", "Stellar", "Stforek",
            "Stick Letters", "Stop", "Straight", "Stronger Than All", "Sub-Zero", "Swamp Land",
            "Swan", "Sweet", "THIS", "Tanja", "Tengwar", "Term", "Test1", "The Edge", "Thick",
            "Thin", "Thorned", "Three Point", "Ticks Slant", "Ticks", "Tiles", "Tinker-Toy",
            "Tombstone", "Train", "Trek", "Tsalagi", "Tubes-Regular", "Tubes-Smushed", "Tubular",
            "Twisted", "Two Point", "USA Flag", "Univers", "Varsity", "Wavy", "Weird",
            "Wet Letter", "Whimsy", "Wow"
        ];

        let currentFont = null;
        let fontCache = {};

        // Initialize fonts
        async function initializeFonts() {
            const select = document.getElementById('fontSelect');
            const status = document.getElementById('status');

            for (const font of allFonts) {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                select.appendChild(option);
            }

            // Load the first font
            if (allFonts.length > 0) {
                select.value = allFonts[2]; // Banner font
                await loadFont(allFonts[2]);
                status.textContent = 'Ready! Fonts loaded.';
            }

            select.addEventListener('change', (e) => {
                loadFont(e.target.value);
            });
        }

        async function loadFont(fontName) {
            const status = document.getElementById('status');
            
            if (fontCache[fontName]) {
                currentFont = fontCache[fontName];
                status.textContent = `Font: ${fontName}`;
                return;
            }

            try {
                status.textContent = `Loading ${fontName}...`;
                const response = await fetch(`ascii-fonts/${fontName}.flf`);
                
                if (!response.ok) {
                    throw new Error(`Font not found: ${fontName}`);
                }

                const fontData = await response.text();
                currentFont = new FLFParser(fontData);
                fontCache[fontName] = currentFont;
                status.textContent = `Font: ${fontName}`;
            } catch (err) {
                console.error('Error loading font:', err);
                status.textContent = `Error loading ${fontName}`;
            }
        }

        // Generate ASCII art
        function generateASCII() {
            if (!currentFont) {
                document.getElementById('output').textContent = 'Font is loading, please wait...';
                return;
            }

            const text = document.getElementById('textInput').value;
            const output = document.getElementById('output');

            if (!text.trim()) {
                output.textContent = 'Please enter some text first!';
                return;
            }

            try {
                const result = currentFont.renderText(text);
                output.textContent = result || 'No output generated';
            } catch (err) {
                output.textContent = `Error: ${err.message}`;
            }
        }

        // Copy to clipboard
        function copyToClipboard() {
            const output = document.getElementById('output').textContent;
            if (!output || output.includes('Error') || output.includes('Please')) {
                return;
            }
            navigator.clipboard.writeText(output).then(() => {
                document.getElementById('status').textContent = 'Copied to clipboard!';
            });
        }

        // Download as text file
        function downloadASCII() {
            const output = document.getElementById('output').textContent;
            if (!output || output.includes('Error') || output.includes('Please')) {
                return;
            }

            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(output));
            element.setAttribute('download', 'ascii-art.txt');
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        // Update preview colors from the color pickers
        function updateColors() {
            const outputEl = document.getElementById('output');
            const textColorEl = document.getElementById('textColor');
            const bgColorEl = document.getElementById('bgColor');
            if (!outputEl) return;
            if (textColorEl) outputEl.style.color = textColorEl.value;
            if (bgColorEl) outputEl.style.background = bgColorEl.value;
        }

        // Download ASCII output as a PNG image
        function downloadPNG() {
            const outputEl = document.getElementById('output');
            const text = outputEl.textContent;
            if (!text || text.includes('Error') || text.includes('Please')) return;

            const lines = text.split('\n');
            const fontSize = 14; // px
            const lineHeight = 1.15;
            const fontFamily = 'Courier New, monospace';

            const tmpCanvas = document.createElement('canvas');
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.font = `${fontSize}px ${fontFamily}`;

            let maxWidth = 0;
            for (const line of lines) {
                const w = tmpCtx.measureText(line).width;
                if (w > maxWidth) maxWidth = w;
            }

            const padding = 20;
            tmpCanvas.width = Math.ceil(maxWidth + padding * 2);
            tmpCanvas.height = Math.ceil(lines.length * fontSize * lineHeight + padding * 2);

            const bgColor = (document.getElementById('bgColor') || { value: '#000000' }).value;
            tmpCtx.fillStyle = bgColor;
            tmpCtx.fillRect(0, 0, tmpCanvas.width, tmpCanvas.height);

            const textColor = (document.getElementById('textColor') || { value: '#ffffff' }).value;
            tmpCtx.fillStyle = textColor;
            tmpCtx.font = `${fontSize}px ${fontFamily}`;
            tmpCtx.textBaseline = 'top';

            for (let i = 0; i < lines.length; i++) {
                tmpCtx.fillText(lines[i], padding, padding + i * fontSize * lineHeight);
            }

            const link = document.createElement('a');
            link.href = tmpCanvas.toDataURL('image/png');
            link.download = 'ascii-art.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Enter key to generate
        document.getElementById('textInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                generateASCII();
            }
        });

        // Background animation
        function initializeBackground() {
            const canvas = document.getElementById('snow');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            resize();
            window.addEventListener('resize', resize);

            class Particle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 2 + 0.5;
                    this.alpha = Math.random() * 0.5 + 0.3;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = 0;
                    if (this.y < 0) this.y = canvas.height;
                    if (this.y > canvas.height) this.y = 0;

                    this.alpha -= 0.002;
                }

                draw() {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            let particles = [];

            for (let i = 0; i < 100; i++) {
                particles.push(new Particle(Math.random() * canvas.width, Math.random() * canvas.height));
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach((p, i) => {
                    p.update();
                    p.draw();

                    if (p.alpha <= 0) {
                        particles[i] = new Particle(Math.random() * canvas.width, Math.random() * canvas.height);
                    }
                });

                requestAnimationFrame(animate);
            }

            animate();
        }

        // Attach color picker listeners and initialize preview colors
        function setupColorControls() {
            const textColorEl = document.getElementById('textColor');
            const bgColorEl = document.getElementById('bgColor');

            if (textColorEl) textColorEl.addEventListener('input', updateColors);
            if (bgColorEl) bgColorEl.addEventListener('input', updateColors);

            // Ensure preview matches initial picker values
            updateColors();
        }

        // Initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeBackground();
                initializeFonts();
                setupColorControls();
            });
        } else {
            initializeBackground();
            initializeFonts();
            setupColorControls();
        }
    </script>
</body>
</html>
