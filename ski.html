<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Alpine Madness</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

<style>
  body { margin: 0; overflow: hidden; background: #ffffff; }
  #info {
    position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 14px;
    background: rgba(0,0,0,0.4); padding: 6px 12px; border-radius: 4px;
    user-select: none;
  }
  #menuBtn {
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 6px 12px;
  background: rgba(20, 20, 20, 0.4);
    border-radius: 12px;
    backdrop-filter: blur(12px) saturate(160%);
    -webkit-backdrop-filter: blur(12px) saturate(160%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  color: white;
  border: none;
  font-size: 14px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1000;
}

#menuPanel {
  position: absolute;
  top: 50px;
  right: 10px;
  background: rgba(20, 20, 20, 0.4);
    border-radius: 12px;
    backdrop-filter: blur(12px) saturate(160%);
    -webkit-backdrop-filter: blur(12px) saturate(160%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  color: white;
  font-family: sans-serif;
  padding: 10px;
  z-index: 1000;
}
#menuPanel input[type="color"],
#menuPanel input[type="range"] {
  margin: 4px 0;
  width: 100%;
}

h3 {
  margin: 0 0 4px;
  font-size: 16px;
  color: #ffffff81;
}

#music-player {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 200px;
    height: 80px;
    background: rgba(20, 20, 20, 0.4);
    border-radius: 12px;
    backdrop-filter: blur(12px) saturate(160%);
    -webkit-backdrop-filter: blur(12px) saturate(160%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    display: flex;
    align-items: center;
    padding: 10px;
    gap: 10px;
    z-index: 1000;
}

#play-btn {
    background: none;
    border: none;
    color: white;
    font-size: 1.4em;
    cursor: pointer;
}

#visualizer {
    flex: 1;
    height: 40px;
}

</style>
</head>
<body>
<div id="info">
  Distance: <span id="distance">0</span> m<br>
  Speed: <span id="speed">0</span> km/h
</div>
<button id="menuBtn">⚙️ Menu</button>
<div id="menuPanel" style="display:none;">
  <h3>Graphics Settings</h3>
  <label>Sky Color: <input type="color" id="skyColor" value="#87ceeb"></label><br>
  <label>Ground Color: <input type="color" id="groundColor" value="#f0f8ff"></label><br>
  <label>Tree Color: <input type="color" id="treeColor" value="#228822"></label><br>
  <label>Ramp Color: <input type="color" id="rampColor" value="#ffffff"></label><br>
  <h3>Fog Settings</h3>
  <label>Fog Density: <input type="range" id="fogDensity" min="0" max="0.1" step="0.001" value="0.03"></label><br>
  <label>Render Distance: <input type="range" id="renderDistance" min="1" max="20" step="1" value="1"></label><br>
  <h3>Reload to see changes</h3>
  <label>Light Color: <input type="color" id="lightColor" value="#ffffff"></label><br>
  <label>Light Intensity: <input type="range" id="lightIntensity" min="0" max="3" step="0.1" value="1.2"></label>
</div>
<div id="music-player">
    <canvas id="visualizer"></canvas>
    <audio id="audio" src="Track.mp3"></audio>
    <button id="play-btn"><i class="fa fa-play"></i></button>
</div>

<script>
    const audio = document.getElementById("audio");
    const canvas = document.getElementById("visualizer");
    const ctx = canvas.getContext("2d");
    const playBtn = document.getElementById("play-btn");

    let isPlaying = false;
    let audioCtx, analyser, source, dataArray;

    playBtn.addEventListener("click", () => {
        if (!audioCtx) initVisualizer();
        if (isPlaying) {
            audio.pause();
            playBtn.innerHTML = '<i class="fa fa-play"></i>';
        } else {
            audio.play();
            playBtn.innerHTML = '<i class="fa fa-pause"></i>';
        }
        isPlaying = !isPlaying;
    });

    function initVisualizer() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        source = audioCtx.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        analyser.fftSize = 64;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);

        canvas.width = 120;
        canvas.height = 40;

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const barWidth = 4;
            const gap = 2;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = dataArray[i] / 8;
                const x = i * (barWidth + gap);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            }
        }
        draw();
    }
</script>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>



let ramps = [];
let scene, camera, renderer;
let clock = new THREE.Clock();
let cameraTilt = 0; // stores smoothed tilt
let strafeDir = 0;

let sunLight;

let treeangle = 0.22 + Math.random() * (0.8 - 0.22);


let flipRotation = 0;   // current flip rotation (radians), positive = frontflip, negative = backflip
let flipSpeed = 0;      // angular speed of flip rotation

let spinRotation = 0;     // current spin rotation (Y-axis), in radians
let spinSpeed = 0;        // angular speed in air (radians/sec)


let rampMaterial;




const slopeAngle = THREE.MathUtils.degToRad(15);

// === CUSTOMIZABLE VARIABLES ===
const playerHeight = 0.4;       // Player camera height from ground
const acceleration = 5;        // How fast player accelerates (units/s²)
const maxSpeed = 60;            // Maximum forward speed
const strafeSpeed = 5;         // Sideways speed

let totalDistance = 0;
let previousPosition = null;

let chunks = localStorage.getItem("chunks") || 1; // Number of chunks to load in each direction

let player = {
  position: new THREE.Vector3(0, 0, 0),
  velocity: new THREE.Vector3(0, 0, 0),
  speed: 10,                   // Start speed lower for acceleration effect
  maxSpeed: maxSpeed,
  acceleration: acceleration,
  friction: 15,
  strafeSpeed: strafeSpeed,
  onGround: true,
  jumpVelocity: 0,
};



let keys = {};
let wasJumpPressed = false; // used to detect spacebar press events

const GRAVITY = -40;
const JUMP_FORCE = 25;

let obstacles = [];
const chunkSize = 50;
const visibleChunks = chunks;

let loadedChunks = new Set();

let groundMesh;

const settings = JSON.parse(localStorage.getItem('skiGameSettings')) || {};
function loadSettingsFromLocalStorage() {
  
  if (settings.skyColor) {
    document.getElementById("skyColor").value = settings.skyColor;
    const c = new THREE.Color(settings.skyColor);
    renderer.setClearColor(c);
    scene.fog.color.copy(c);
  }
  if (settings.groundColor) {
    document.getElementById("groundColor").value = settings.groundColor;
    groundMesh.material.color.set(settings.groundColor);
  }
  if (settings.treeColor) {
    document.getElementById("treeColor").value = settings.treeColor;
    currentTreeColor = new THREE.Color(settings.treeColor);
  }
  if (settings.rampColor) {
    document.getElementById("rampColor").value = settings.rampColor;
    rampMaterial.color.set(settings.rampColor);
  }
  if (settings.fogDensity) {
    document.getElementById("fogDensity").value = settings.fogDensity;
    scene.fog.density = parseFloat(settings.fogDensity);
  }
  if (settings.renderDistance) {
    document.getElementById("renderDistance").value = settings.renderDistance;
    chunks = parseInt(settings.renderDistance);
  }
  if (settings.lightColor) {
    document.getElementById("lightColor").value = settings.lightColor;
    sunLight.color.set(settings.lightColor);
  }
  if (settings.lightIntensity) {
    document.getElementById("lightIntensity").value = settings.lightIntensity;
    sunLight.intensity = parseFloat(settings.lightIntensity);
  }
}

if (settings.treeColor) {
  currentTreeColor = new THREE.Color(settings.treeColor);
}

init();
loadSettingsFromLocalStorage();
animate();


function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x87ceeb, 0.03);

  setInterval(() => {
  treeangle = 0.22 + Math.random() * (0.8 - 0.22); // update every 5 seconds
}, 5000);



  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setClearColor(0x87ceeb);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(10, 20, 10);
scene.add(sunLight);

// Add soft ambient light to reduce black shadows
const ambientLight = new THREE.AmbientLight(lightColor, 0.2); // soft white light
scene.add(ambientLight);



  // Large ground plane, no seams
  const size = chunkSize * visibleChunks * 10;
  const segments = 64;
  let groundGeo = new THREE.PlaneGeometry(size, size, segments, segments);
  let groundMat = new THREE.MeshLambertMaterial({color: 0xf0f8ff});
  groundMesh = new THREE.Mesh(groundGeo, groundMat);
  groundMesh.rotation.x = -Math.PI/2 + slopeAngle;
  groundMesh.position.y = player.position.y - playerHeight;
  scene.add(groundMesh);

  rampMaterial = new THREE.MeshLambertMaterial({ color: settings.rampColor || 0xffffff });

  // Initial player height based on custom playerHeight
  player.position.y = getTerrainHeight(player.position.x, player.position.z) + playerHeight;

  // Spawn obstacles initially (randomized)
  for (let dx = -visibleChunks; dx <= visibleChunks; dx++) {
    for (let dz = -visibleChunks; dz <= visibleChunks; dz++) {
      spawnObstaclesChunk(dx, dz);
    }
  }

  window.addEventListener('keydown', (e) => keys[e.code] = true);
  window.addEventListener('keyup', (e) => keys[e.code] = false);
  window.addEventListener('resize', onWindowResize);
}

function getTerrainHeight(x, z) {
  return Math.tan(-slopeAngle) * z;
}

// Fully random obstacle generation per chunk
function spawnObstaclesChunk(chunkX, chunkZ) {
  const chunkKey = `${chunkX},${chunkZ}`;
  if (loadedChunks.has(chunkKey)) return;
  loadedChunks.add(chunkKey);

  const numObstacles = 10 + Math.floor(Math.random() * 5);

  for (let i = 0; i < numObstacles; i++) {
    const x = chunkX * chunkSize + Math.random() * chunkSize;
    const z = chunkZ * chunkSize + Math.random() * chunkSize;

    const r = Math.random();
    if (r < 0.6) {
      createObstacle('tree', x, z);
    } else if (r < 0.65) {
      createRamp(x, z, 7, 5, 5);
    }
  }
}

function createObstacle(type, x, z) {
  if (type === 'tree') {
    const tree = new THREE.Group();

    // Use the global currentTreeColor THREE.Color instance here
    const coneGeo = new THREE.ConeGeometry(0.8, 3, 8);
    const coneMat = new THREE.MeshLambertMaterial({ color: currentTreeColor });
    const cone = new THREE.Mesh(coneGeo, coneMat);

    const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
    const trunkMat = new THREE.MeshLambertMaterial({color: 0x8b4513});
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1;
    cone.position.y = 2.5; // Position cone above trunk

    tree.add(trunk);
    tree.add(cone);
    tree.position.set(x, getTerrainHeight(x,z), z);
    tree.rotation.x = treeangle; // Tilt trees slightly
    scene.add(tree);
    const hitboxOffset = new THREE.Vector3(0, 0, -4); // push hitbox *backward* (adjust as needed)
    const hitboxPos = tree.position.clone().add(hitboxOffset);
    obstacles.push({ mesh: tree, radius: 2.4, position: hitboxPos });
  }
}




function createRamp(x, z, width = 7, length = 5, height = 5) {
  const rampGeo = new THREE.BoxGeometry(width, height, length);
  const rampMat = rampMaterial;
  const rampMesh = new THREE.Mesh(rampGeo, rampMat);
  rampMesh.position.set(x, getTerrainHeight(x, z) - 1, z);  
  rampMesh.rotation.x = 180; // Rotate to face forward
  scene.add(rampMesh);
  ramps.push({ mesh: rampMesh, position: rampMesh.position, width: 10, length, height });
}


function updateTerrainChunks() {
  const playerChunkX = Math.floor(player.position.x / chunkSize);
  const playerChunkZ = Math.floor(player.position.z / chunkSize);

  for (let dx = -visibleChunks; dx <= visibleChunks; dx++) {
    for (let dz = -visibleChunks; dz <= visibleChunks; dz++) {
      const chunkX = playerChunkX + dx;
      const chunkZ = playerChunkZ + dz;
      spawnObstaclesChunk(chunkX, chunkZ);
    }
  }
}

function despawnObsoleteObjects() {
  const despawnZ = player.position.z + 50; // Anything behind this Z is removed

  // Remove obstacles
  obstacles = obstacles.filter(obj => {
    if (obj.position.z > despawnZ) {
      scene.remove(obj.mesh);
      return false; // Remove from array
    }
    return true; // Keep in array
  });

  // Remove ramps
  ramps = ramps.filter(ramp => {
    if (ramp.position.z > despawnZ) {
      scene.remove(ramp.mesh);
      return false;
    }
    return true;
  });
}


function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  let dt = clock.getDelta();
  
  updatePlayer(dt);
  updateTerrainChunks();
  despawnObsoleteObjects();
  // Move ground to stay centered under player
  groundMesh.position.x = player.position.x;
  groundMesh.position.z = player.position.z;

  // === DISTANCE TRACKING ===
if (previousPosition) {
  const delta = player.position.clone().sub(previousPosition);
  delta.y = 0; // ignore vertical movement
  totalDistance += delta.length();
}
previousPosition = player.position.clone();

  
  // Smooth FOV increase based on current speed and acceleration ratio
  // Calculate speed ratio for normal speed range
let targetFov;
if (keys['KeyW'] && player.onGround || keys['ArrowUp'] && player.onGround) {
  // Force rapid FOV boost when W is held
  targetFov = 110;
} else {
  // Normal FOV based on speed
  let speedRatio = (player.speed - 10) / (player.maxSpeed - 10);
  speedRatio = THREE.MathUtils.clamp(speedRatio, 0, 1);
  targetFov = THREE.MathUtils.lerp(75, 95, speedRatio);
}

// Smooth interpolation toward target FOV
camera.fov += (targetFov - camera.fov) * 0.2;
camera.updateProjectionMatrix();


  const forward = new THREE.Vector3(0, 0, -1);
  const cameraOffset = new THREE.Vector3(
    0, playerHeight + Math.sin(clock.elapsedTime * 6) * 0.07, 6
  );
  camera.position.copy(player.position).add(cameraOffset);

  let lookAtPos = player.position.clone().add(forward.multiplyScalar(10));
  lookAtPos.y += playerHeight;
  camera.lookAt(lookAtPos);

  // === SPIN / FLIP LOGIC ===
spinRotation += spinSpeed * dt;
spinSpeed *= 0.96; // apply damping

// LANDING SNAP
if (player.onGround) {
  // Snap to nearest 180 degrees (0 or π)
  const snapped = Math.round(spinRotation / Math.PI) * Math.PI;
  spinRotation += (snapped - spinRotation) * 0.2; // smooth but fast snap
  if (Math.abs(snapped - spinRotation) < 0.01) {
    spinRotation = snapped;
    spinSpeed = 0;
  }
}

// Apply all camera rotations
camera.rotation.x = flipRotation;
camera.rotation.z = cameraTilt;
camera.rotation.y = spinRotation;

  
// === CAMERA TILT WHEN TURNING ===
const maxTilt = Math.PI / 32  ; // ~11 degrees
const tiltTarget = -strafeDir * maxTilt;
cameraTilt += (tiltTarget - cameraTilt) * 0.1; // smoothing
camera.rotation.z = cameraTilt;

// Update flip rotation and apply damping
flipRotation += flipSpeed * dt;
flipSpeed *= 0.95;  // dampen flip speed gradually

// Keep rotation angle normalized (optional)
if (flipRotation > Math.PI * 2) flipRotation -= Math.PI * 2;
if (flipRotation < -Math.PI * 2) flipRotation += Math.PI * 2;

// Smoothly reset rotation when on ground
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= Math.PI * 2;
  while (angle < -Math.PI) angle += Math.PI * 2;
  return angle;
}

if (player.onGround) {
  // Normalize current flipRotation first
  flipRotation = normalizeAngle(flipRotation);

  // Calculate shortest difference to zero
  const diff = normalizeAngle(0 - flipRotation);

  // Smoothly ease rotation back to zero
  flipRotation += diff * 0.08;

  // Stop flipping if close enough
  if (Math.abs(diff) < 0.01) flipSpeed = 0;
}

// === UPDATE UI ===
document.getElementById('distance').textContent = Math.floor(totalDistance * 0.5).toLocaleString();
const kmh = player.speed * 1.5;
document.getElementById('speed').textContent = Math.round(kmh);
// === RENDER SCENE ===


// Apply flip rotation as camera pitch (rotation around X-axis)
camera.rotation.x = flipRotation;


  renderer.render(scene, camera);
}

function updatePlayer(dt) {
  const forward = new THREE.Vector3(0, 0, -1);
  const right = new THREE.Vector3(1, 0, 0);
  if (player.onGround === true) {
    groundMesh.position.y = player.position.y;
  } else {
    groundMesh.position.y = player.position.y - player.jumpOffset; // Slightly raised when in air
  }
  // Calculate desired target strafe dir
let targetStrafeDir = 0;
if (player.onGround) {
  if (keys['KeyA'] || keys['ArrowLeft']) targetStrafeDir = -2 * player.speed / 16;
  else if (keys['KeyD'] || keys['ArrowRight']) targetStrafeDir = 2 * player.speed/ 16 ;
  else targetStrafeDir = 0;
  let boosting = false;
  // JUMP on spacebar press
if ((keys['Space'] || keys['ArrowUp']) && player.onGround && !wasJumpPressed) {
  player.jumpVelocity = JUMP_FORCE;
  player.onGround = false;
  wasJumpPressed = true;
}
if (!keys['Space'] && !keys['ArrowUp']) {
  wasJumpPressed = false;
}


if (keys['KeyW']  && player.onGround || keys['ArrowUp'] && player.onGround  ) {
  boosting = true;
  player.speed += player.acceleration * 2 * dt;  // boost acceleration (e.g. double)
  if (player.speed > player.maxSpeed * 1.5) player.speed = player.maxSpeed * 1.5; // cap boosted max speed
} else {
  // normal acceleration
  if (player.speed < player.maxSpeed) {
    player.speed += player.acceleration * dt;
    if (player.speed > player.maxSpeed) player.speed = player.maxSpeed;
  }
}

  if (keys['KeyS'] || keys['ArrowDown']) player.speed *= 0.95; // slow down when braking
} else {
  targetStrafeDir = 0; // no strafing in air, optional
}



if (!player.onGround) {
  if (keys['KeyA']) {
    spinSpeed += Math.PI * 8 * dt;   // left spin (360° per second)
  }
  if (keys['KeyD']) {
    spinSpeed -= Math.PI * 8 * dt;   // right spin
  }

  if (keys['KeyW']) {
    flipSpeed -= Math.PI * 8 * dt;   // frontflip
  }
  if (keys['KeyS']) {
    flipSpeed += Math.PI * 8 * dt;   // backflip
  }
}


// Smoothly approach target strafe dir
const strafeLerpSpeed = 3; // adjust to taste
strafeDir += (targetStrafeDir - strafeDir) * strafeLerpSpeed * dt;


  // Gradually accelerate forward speed if below maxSpeed
  if (player.speed < player.maxSpeed) {
    player.speed += player.acceleration * dt;
    if (player.speed > player.maxSpeed) player.speed = player.maxSpeed;
  }
  let strafeVelocity = right.clone().multiplyScalar(strafeDir * player.strafeSpeed);
  let forwardVelocity = forward.clone().multiplyScalar(player.speed);

  let nextPos = player.position.clone().add(forwardVelocity.clone().add(strafeVelocity).multiplyScalar(dt));

  // Collision detection: prevent moving into obstacles
  for (let obj of obstacles) {
    let dist = obj.position.distanceTo(nextPos);
    if (dist < obj.radius && nextPos.y <= getTerrainHeight(nextPos.x, nextPos.z) + 3) {
      let pushDir = nextPos.clone().sub(obj.position);
      pushDir.y = 0;
      player.speed = player.speed * 0.95; // Reduce speed on collision
      if (pushDir.length() === 0) {
        pushDir = forward.clone().negate();
      } else {
        pushDir.normalize();
      }
      let velVec = forwardVelocity.clone().add(strafeVelocity);
      let dot = velVec.dot(pushDir);
      if (dot < 0) {
        let correction = pushDir.multiplyScalar(dot);
        velVec.sub(correction);
        forwardVelocity = velVec.clone().projectOnVector(forward).multiplyScalar(1);
        strafeVelocity = velVec.clone().projectOnVector(right).multiplyScalar(1);
      }
    }
  }

  // RAMP JUMPING: Check if player hits front edge of any ramp
  for (const ramp of ramps) {
    let dx = nextPos.x - ramp.position.x;
    let dz = nextPos.z - ramp.position.z;
    if (
      Math.abs(dx) <= ramp.width / 2 &&
      dz > -ramp.length / 2 - 1 && dz < -ramp.length / 2 + 1 &&
      player.onGround
    ) {
      player.jumpVelocity = player.speed * 0.7; // Boost jump based on speed
      player.onGround = false;
    }
  }

  player.velocity.copy(forwardVelocity).add(strafeVelocity);

  if (player.onGround) {
    player.velocity.y = Math.sin(slopeAngle) * player.speed;
  } else {
    player.jumpVelocity += GRAVITY * dt;
    player.velocity.y = player.jumpVelocity;
  }

  player.position.addScaledVector(player.velocity, dt);

  const groundHeight = getTerrainHeight(player.position.x, player.position.z) + playerHeight;
  player.jumpOffset = player.position.y - groundHeight;
  if (player.position.y <= groundHeight) {
    player.position.y = groundHeight;
    player.onGround = true;
    player.jumpVelocity = 0;
  } else {
    player.onGround = false;
  }
}

document.getElementById("menuBtn").addEventListener("click", () => {
  const panel = document.getElementById("menuPanel");
  panel.style.display = panel.style.display === "none" ? "block" : "none";
});

function saveSettingsToLocalStorage() {
  const settings = {
    skyColor: document.getElementById("skyColor").value,
    groundColor: document.getElementById("groundColor").value,
    treeColor: document.getElementById("treeColor").value,
    rampColor: document.getElementById("rampColor").value,
    fogDensity: document.getElementById("fogDensity").value,
    renderDistance: document.getElementById("renderDistance").value,
    lightColor: document.getElementById("lightColor").value,
    lightIntensity: document.getElementById("lightIntensity").value
  };
  localStorage.setItem('skiGameSettings', JSON.stringify(settings));
}


document.getElementById("skyColor").addEventListener("input", (e) => {
  const c = new THREE.Color(e.target.value);
  renderer.setClearColor(c);
  scene.fog.color.copy(c);
  saveSettingsToLocalStorage();
});

document.getElementById("groundColor").addEventListener("input", (e) => {
  const c = new THREE.Color(e.target.value);
  groundMesh.material.color.set(c);
  saveSettingsToLocalStorage();
});

document.getElementById("treeColor").addEventListener("input", (e) => {
  const color = new THREE.Color(e.target.value);
  currentTreeColor = color;
  obstacles.forEach(obj => {
    if (obj.mesh && obj.mesh.children) {
      obj.mesh.children.forEach(child => {
        if (child.geometry.type === "ConeGeometry") {
          child.material.color.set(color);
        }
      });
    }
  });
  saveSettingsToLocalStorage();
});

document.getElementById("rampColor").addEventListener("input", (e) => {
  const color = new THREE.Color(e.target.value);
  rampMaterial.color.set(color);
  // Update all existing ramp meshes
ramps.forEach(r => r.mesh.material.color.set(color));

  saveSettingsToLocalStorage();
});


document.getElementById("fogDensity").addEventListener("input", (e) => {
  const d = parseFloat(e.target.value);
  scene.fog.density = d;
  saveSettingsToLocalStorage();
});

document.getElementById("renderDistance").addEventListener("input", (e) => {
  chunks = parseInt(e.target.value);
  localStorage.setItem("chunks", chunks); // still storing this directly
  saveSettingsToLocalStorage();
});

document.getElementById("lightColor").addEventListener("input", (e) => {
  sunLight.color.set(e.target.value);
  saveSettingsToLocalStorage();
});

document.getElementById("lightIntensity").addEventListener("input", (e) => {
  sunLight.intensity = parseFloat(e.target.value);
  saveSettingsToLocalStorage();
});


document.getElementById("renderDistance").addEventListener("input", (e) => {
  chunks = parseInt(e.target.value);
  localStorage.setItem("chunks", chunks);
});


// === MOBILE TOUCH CONTROLS (Diagonal Filtering) ===


let touchState = {
  lastTap: 0,
  activeTouches: {},
};

function simulateKey(code, isDown) {
  keys[code] = isDown;
}

function handleTouchStart(e) {
  const now = performance.now();
  for (const touch of e.changedTouches) {
    const { clientX, clientY, identifier } = touch;
    const halfWidth = window.innerWidth / 2;
    const zone = clientX < halfWidth ? "left" : "right";

    touchState.activeTouches[identifier] = {
      startX: clientX,
      startY: clientY,
      zone,
      startTime: now,
      activeKeys: {},
    };

    // Tap detection (quick double tap = jump)
    if (now - touchState.lastTap < 300) {
      simulateKey("Space", true);
      touchState.activeTouches[identifier].activeKeys["Space"] = true;
    }

    touchState.lastTap = now;
  }
}

function handleTouchMove(e) {
  for (const touch of e.changedTouches) {
    const id = touch.identifier;
    const state = touchState.activeTouches[id];
    if (!state) continue;

    const dx = touch.clientX - state.startX;
    const dy = touch.clientY - state.startY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    // Reset all previously simulated keys
    for (const key in state.activeKeys) {
      simulateKey(key, false);
    }
    state.activeKeys = {};

    const horizontalThreshold = 30;
    const verticalThreshold = 30;

    if (absDx > absDy * 1.5 && absDx > horizontalThreshold) {
      // Strong horizontal drag (left/right)
      if (dx < 0 && state.zone === "left") {
        simulateKey("KeyA", true);
        state.activeKeys["KeyA"] = true;
      } else if (dx > 0 && state.zone === "right") {
        simulateKey("KeyD", true);
        state.activeKeys["KeyD"] = true;
      }
    } else if (absDy > absDx * 1.5 && absDy > verticalThreshold) {
      // Strong vertical drag (up/down)
      if (dy > 0) {
        simulateKey("KeyS", true); // drag down
        state.activeKeys["KeyS"] = true;
      } else {
        simulateKey("KeyW", true); // drag up
        state.activeKeys["KeyW"] = true;
      }
    }
  }
}

function handleTouchEnd(e) {
  for (const touch of e.changedTouches) {
    const id = touch.identifier;
    const state = touchState.activeTouches[id];
    if (!state) continue;

    for (const key in state.activeKeys) {
      simulateKey(key, false);
    }
    delete touchState.activeTouches[id];
  }

  // Always release Space (jump) if it was triggered
  simulateKey("Space", false);
}

// Register
window.addEventListener("touchstart", handleTouchStart, { passive: false });
window.addEventListener("touchmove", handleTouchMove, { passive: false });
window.addEventListener("touchend", handleTouchEnd, { passive: false });



</script>
</body>
</html>
